# Starting a new project
Whether you’re developing a full-fledged software package or simply organising a collection of scripts, it is essential to start your project with a clear and well-structured organisation. Doing so will help keep your code clean, readable, and maintainable, while also making it easier to share and collaborate with others.

Below are some key recommendations and considerations to keep in mind when starting a new project, with a particular focus on R and Python.

# Organising Data in a R project
Rstudio is the most widely used integrated development environment by R users and developers. It is highly recommended to use it.  

## Creating a Rstudio project

Choose the menu File / New Project / New Directory / New Project. Choose a directory name without accent and blanck space. A .Rproj file will be created at the project root.

Once the .Rproj file has been created, it is essential to get the project off to a good start, by deciding on an organisation that must be respected over time.    
Choose a structure that works well for you and stick to it as much as possible. Below is a suggested way of organising the code:


```
my_project/     		
├── code/          		        # Script directory
│   └── myscript.sh
│   └── setup_env.R             
├── data/          		        # Raw data directory
│   └── data.csv
├── results/     		        # Analysis results directory
├── tests/          		    # Temporary test code
│   └── my_temporary_script.R
├── tmp/                        
├── .gitignore 
├── LICENSE 
└── README.md
```

**Mandatory**:  
- `README.md` file. This file is arguably **the most important** file you’ll create in your project. It should provide a clear overview of the code’s purpose, including:
    - The goal of the project
    - Set-up and execution instructions
    - If no separate documents exist (e.g., architecture diagram or system maintenance guide), a high-level explanation of how the code is structured and works  
- `LICENSE` file. It is a file that contains the license under which the package is distributed. Maybe the first file to add to your project. You can choose a license from [choosealicence](https://choosealicense.com).  


!!! warning "The `README.md` is not the place to describe individual functions in detail"  
     Keep it high-level and accessible.  
     The `README.md` is a living document. As your code evolves, make sure to keep the documentation up to date.  
     Don’t postpone writing it until the end of the project — by then, you’ll likely be racing against deadlines and already thinking about your next project.  
     Start documenting early. It will save you time and effort later. 

**File / directories to be created:**  
- `Cluster_logs` directory. It contains logs files redirected from standard output (`.out`) and standard error (`.err`).
- `code/` directory. It contains scripts, in the form of `.R`, `.sh`, `.py` files.  
- `data/` directory. It contains data to be analyzed (.csv, .vcf...).  
- `results/` directory. It contains outputs. It is recommended to add subdirectories in this directory.  
- `tests/` directory. Code tests should go in here.  
- `tmp/`directory. It is used to store temporary files generated by the programs or workflows within this project. It serves as a local alternative to the system’s default $TMPDIR, which is often saturated or unreliable on shared cluster environments.  
- `.gitignore`. In this file, you add everything you do not want ending up in your remote repository. As a minimum, add `tmp/` file in there.  

**Automatically created if you add renv:**  
- `renv.lock` file, `renv/` folder and `.Rprofile` file. This is the virtual environment set up. They will be automatically created by renv when you activate it.  
- `.Rproj` file. This is an RStudio file containing the project specific settings. Created automatically when you create an R project with RStudio ON Demand (see further). 

To create directories: `mkdir -p Cluster_logs data code results tests tmp` in a Terminal.

## Start Version Control With Github/Gitlab
```bash
git init
```

## Running R Scripts in a Clean & Reproducible Manner

When launching R scripts, it is highly recommended to run them in a clean environment to ensure reproducibility and avoid unexpected side effects caused by user-specific configurations. By creating a R projects, you isolate your work from other projects. Not only can you have project specific files and libraries, but also project specific settings. To do so, you just have to create `renv` environment.

### Use renv::init()

`renv::init()` does several important things:   

1.	Creates the renv/ infrastructure in your project:  
      1. `renv/`directory with configuration files  
      2. `Rprofile` file that activates `renv` at start-up  
      3. `renv.lock` file (empty at start)  
2.	Isolates the environment: creates a private package library for this project only.  
3.	Scans the existing code to automatically detect the packages used (via library(), require() ...)  
4.	Installs the detected packages in the project's private library (NOT all, unfortunatelly...)  

### How to
1. If you haven't already done so, go into the project's directory 
```bash
cd /path/to/my_project/
```

2. Create a setup_env.R file 
```bash
vim code/setup_env.R
```
```R
#!/usr/bin/env Rscript
# setup_env.R

cat("Setting up R environment...\n")

# 1. Install renv first (required before)
if (!requireNamespace("renv", quietly = TRUE)) {
    cat("Installing renv package...\n")
    install.packages("renv", repos = "https://cran.r-project.org/")
}

# 2. Initialize renv for this projet
cat("Initializing renv environment...\n")
renv::init()

# 3. List all necessary packages
required_packages <- c(
    "data.table",
    "ggplot2",
    "dplyr",
    "parallel",
    "BiocManager"			# For Bioconductor packages if necessary
)

# 4. CRAN packages management
cat("Installing CRAN packages...\n")
install.packages(required_packages)

# 5. Bioconductor packages management
if ("BiocManager" %in% required_packages) {
    cat("Installing Bioconductor packages...\n")
    BiocManager::install(c("DESeq2", "edgeR"))		# examples
}

# 6. Final snapshot - Freeze all
cat("Creating final snapshot...\n")
renv::snapshot()

# 7. Final checkup
cat("Setup completed. Session info:\n")
sessionInfo()
```
Save the file and quit vim by **pressing escape** and entering the following command :
```bash
:wq
```
At this step, you should already have made a list of the packages needed for the analyses. If you need to add packages during the analysis, simply edit this file and run it again.  

3. Run the script in RStudio

Choose File / Open File... and select setup_env.R in the code/ directory. Then select Run.


## Useful R packages

- `devtools` : a package that provides functions to ease the development of R packages, by executing common tasks like documentation, testing, etc. e.g.:
1. `devtools::document()` : generates the NAMESPACE file and documentation files for your functions
2. `devtools::load_all()` : loads your code and functions in the R environment, so that you can test them immediately
3. `devtools::test()` : runs the tests you have written for your functions
- `usethis` : workflow automation package for R projects for setting up and develop projects, e.g.:
1. `usethis::use_git()` : initializes a git repository in your project
2. `usethis::use_testthat()` : initializes the testthat package in your project
3. `usethis::use_package("package")` : adds a package to the DESCRIPTION file as a dependency of your package
4. `usethis::use_r()` : creates a new R script in the R/ sub-repository
5. `usethis::use_test("myTest")` : creates a new test script tests/testthat/test-myTest.R
- `here` : a package that provides functions to easily refer to files in your project, e.g.:
1. `here::here()` : returns the path to the project root
2. `here::here("R", "my_function.R")` : returns the path to the my_function.R file in the R sub-repository
- `testthat` : a package that provides functions to write and run tests for your functions. Check the official documentation and the dedicated section to see how to write tests. 
Once you have initiated your tests with usethis::use_testthat(), you can write tests in the tests/testthat/ sub-repository:
1. `usethis::use_test("my_function")` : creates a new test script tests/testthat/test-my_function.R
2. `devtools::test()` : to run the tests.


# Organising Data in a Python Project

Python is widely used for data science, bioinformatics, and HPC workflows. On a cluster, it’s essential to manage environments carefully to avoid dependency conflicts and ensure reproducibility.

## Organize your code

Below is a suggested way of organizing the code, with some files and directories created automatically:
```
my_project/ 
├── code/          		        # Script directory
│   └── myscript.py
├── data/          		        # Raw data directory
│   └── data.csv
├── results/     		        # Analysis results directory
├── tests/          		    # Temporary test code
│   └── my_temporary_script.py
├── tmp/    
├── venv/          		        # Python virtual env.
│   └── bin/
│         └── activate
│   └── include/
│   └── lib/
│   └── pyenv.cfg
├── LICENSE 
└── README.md
```
- **LICENSE** : a file that contains the license under which the package is distributed. Maybe the first file to add to your project. You can choose a license from [choosealicence](https://choosealicense.com).



## Best Practices for Running Python Jobs

Before launching a job, make sure your script runs in a controlled Python environment.

### With venv (standard Python)

```python
python -m venv myenv
source myenv/bin/activate
pip install -r requirements.txt
```

the file requirements.txt contains, for example:
```python
numpy==1.26.4
pandas>=2.2.0
scipy<1.12
matplotlib
seaborn==0.12.2
scikit-learn>=1.3
jupyterlab
requests
biopython
```

### With conda:
```conda
conda create -n myenv python=3.11
conda activate myenv
conda install numpy pandas scipy  # etc.
```

Once set up, activate your environment inside your IDE before running your script.


## Start Version Control With Github/Gitlab
```bash
git init
```